package com.github.jonmarsh.waveform_processing_for_imagej;

import ij.IJ;
import ij.ImagePlus;
import ij.gui.DialogListener;
import ij.gui.GenericDialog;
import ij.plugin.filter.ExtendedPlugInFilter;
import ij.plugin.filter.PlugInFilterRunner;
import ij.process.ImageProcessor;
import ij.util.Tools;
import java.awt.AWTEvent;

/**
 * This plugin filter moves a sliding gate along each waveform (horizontal line)
 * in an image and returns the range (max_value - min_value) as the new value at
 * that index. The input data are overwritten by the new computed values. The
 * length of the moving window is equal to {@code 2*radius+1}. At positions
 * where portions of the moving window lie outside the bounds of the waveform,
 * the waveform values are mirrored about the end points.
 * <p>
 * @author Jon N. Marsh
 */
public class MovingWindowRange implements ExtendedPlugInFilter, DialogListener
{
	private int width;
	private static int radius = 1;
	private GenericDialog gd;
	private final int flags = DOES_32 + DOES_STACKS + PARALLELIZE_STACKS + KEEP_PREVIEW + FINAL_PROCESSING;

	@Override
	public int setup(String arg, ImagePlus imp)
	{
		if (arg.equals("final")) {
			IJ.resetMinAndMax();
			return DONE;
		}

		if (imp == null) {
			IJ.noImage();
			return DONE;
		}

		width = imp.getWidth();

		return flags;
	}

	@Override
	public int showDialog(ImagePlus imp, String command, PlugInFilterRunner pfr)
	{
		gd = new GenericDialog("Moving Window Sum of Squares...");
		gd.addNumericField("Radius", radius, 0);
		gd.addPreviewCheckbox(pfr);
		gd.addDialogListener(this);

		gd.showDialog();
		if (gd.wasCanceled()) {
			return DONE;
		}

		return flags;
	}

	@Override
	public boolean dialogItemChanged(GenericDialog gd, AWTEvent e)
	{
		radius = (int)gd.getNextNumber();

		return (!gd.invalidNumber() && radius >= 0);
	}

	@Override
	public void run(ImageProcessor ip)
	{
		float[] pixels = (float[])ip.getPixels();
		double[] pixelsDouble = Tools.toDouble(pixels);

		execute(pixelsDouble, width, radius);
		
		for (int i=0; i<pixels.length; i++) {
			pixels[i] = (float)pixelsDouble[i];
		}
	}

	/**
	 * Applies a moving window to each record in {@code waveforms} (where each
	 * record is of length {@code recordLength}) and replaces the original value
	 * at that point with the range (i.e. max-min) within the window. The moving
	 * window is of length {@code 2*radius+1}. Input waveforms are left
	 * unchanged if the array representing them is null,
	 * {@code 2*radius+1>recordLength}, {@code radius<0}, or
	 * {@code waveforms.length} is not evenly divisible by {@code recordLength}.
	 * At positions where a part of the moving window lies outside the bounds of
	 * the waveform, the missing waveform values are generated by reflection
	 * around the appropriate end point.
	 * <p>
	 * @param waveforms	   one-dimensional array composed of a series of
	 *                     concatenated records, each of size equal to
	 *                     {@code recordLength}
	 * @param recordLength size of each record in {@code waveforms}
	 * @param radius       length of two-sided window function is equal to
	 *                     {@code 2*radius+1}
	 *
	 */
	public static final void execute(double[] waveforms, int recordLength, int radius)
	{
		int windowLength = 2 * radius + 1;

		if (waveforms != null && recordLength > windowLength && waveforms.length % recordLength == 0 && radius >= 0) {

			// compute number of records
			int numRecords = waveforms.length / recordLength;

			// loop over all records
			for (int i = 0; i < numRecords; i++) {

				// compute row offset
				int offset = i * recordLength;

				// initialize copy of current waveform
				double[] currentWaveformCopy = new double[recordLength];
				for (int j = 0; j < recordLength; j++) {
					currentWaveformCopy[j] = waveforms[offset + j];
				}

				// move window and compute range
				for (int j = 0; j < recordLength; j++) {

					// initialize max and min
					int index;
					double max = Double.NEGATIVE_INFINITY;
					double min = Double.POSITIVE_INFINITY;

					// compute the range at the current index (brute force algorithm, but fast enough for this simple metric)
					for (int k = -radius; k <= radius; k++) {
						index = j + k;
						if (index < 0) {
							index = -index;
						} else if (index > recordLength - 1) {
							index = 2 * (recordLength - 1) - index;
						}
						if (currentWaveformCopy[index] > max) {
							max = currentWaveformCopy[index];
						}
						if (currentWaveformCopy[index] < min) {
							min = currentWaveformCopy[index];
						}
					}

					waveforms[offset + j] = max - min;

				}

			}

		}

	}

	@Override
	public void setNPasses(int nPasses)
	{
	}

}
